<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 6: Execute Pipeline - Nginx Stress-Test</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Plus+Jakarta+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #ffffff; --bg-secondary: #f8fafc; --bg-tertiary: #f1f5f9; --bg-card: #ffffff;
            --accent-primary: #0ea5e9; --accent-secondary: #6366f1; --accent-success: #10b981; --accent-warning: #f59e0b; --accent-danger: #ef4444;
            --text-primary: #0f172a; --text-secondary: #475569; --text-muted: #94a3b8;
            --border-color: #e2e8f0;
            --gradient-1: linear-gradient(135deg, #0ea5e9 0%, #6366f1 100%);
            --gradient-execute: linear-gradient(135deg, #10b981 0%, #0ea5e9 100%);
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Plus Jakarta Sans', sans-serif; background: var(--bg-secondary); color: var(--text-primary); min-height: 100vh; }
        .container { max-width: 1100px; margin: 0 auto; padding: 40px 24px; }
        .breadcrumb { display: flex; gap: 8px; margin-bottom: 32px; font-size: 14px; color: var(--text-muted); }
        .breadcrumb a { color: var(--accent-primary); text-decoration: none; }
        .page-header { display: flex; align-items: center; gap: 20px; margin-bottom: 40px; }
        .step-badge { width: 64px; height: 64px; background: var(--gradient-execute); border-radius: 16px; display: flex; align-items: center; justify-content: center; font-size: 28px; font-weight: 700; color: white; }
        .page-title h1 { font-size: 32px; font-weight: 700; margin-bottom: 4px; }
        .page-title p { font-size: 16px; color: var(--text-secondary); }
        .flow-nav { display: flex; justify-content: center; gap: 8px; margin-bottom: 40px; flex-wrap: wrap; }
        .nav-pill { padding: 8px 16px; background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 100px; color: var(--text-secondary); text-decoration: none; font-weight: 500; font-size: 12px; box-shadow: var(--shadow-sm); }
        .nav-pill:hover { border-color: var(--accent-primary); color: var(--accent-primary); }
        .nav-pill.active { background: var(--gradient-execute); border-color: transparent; color: white; }

        .card { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 16px; padding: 28px; margin-bottom: 24px; box-shadow: var(--shadow-sm); }
        .card h2 { font-size: 18px; margin-bottom: 20px; color: var(--text-primary); }
        .card h3 { font-size: 15px; margin: 20px 0 12px; color: var(--text-secondary); }

        .code-block { background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 10px; padding: 16px; font-family: 'JetBrains Mono', monospace; font-size: 12px; color: var(--text-primary); overflow-x: auto; white-space: pre; }
        .code-block.large { padding: 20px; }

        .exec-flow { display: flex; align-items: center; justify-content: center; gap: 16px; padding: 24px; background: var(--bg-tertiary); border-radius: 12px; flex-wrap: wrap; margin-bottom: 20px; }
        .flow-box { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 12px; padding: 14px 20px; text-align: center; min-width: 100px; }
        .flow-box.highlight { border-color: var(--accent-success); box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1); }
        .flow-box .icon { font-size: 22px; margin-bottom: 4px; }
        .flow-box .label { font-size: 11px; font-weight: 600; color: var(--text-secondary); }
        .flow-arrow { font-size: 18px; color: var(--accent-success); }

        .method-badge { display: inline-block; padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; margin-right: 8px; }
        .method-recommended { background: rgba(16, 185, 129, 0.1); color: var(--accent-success); }
        .method-alternative { background: rgba(99, 102, 241, 0.1); color: var(--accent-secondary); }

        .checklist { list-style: none; }
        .checklist li { padding: 14px 0; display: flex; align-items: center; gap: 12px; border-bottom: 1px solid var(--border-color); font-size: 14px; }
        .checklist li:last-child { border-bottom: none; }
        .check-icon { width: 24px; height: 24px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 12px; background: rgba(16, 185, 129, 0.1); color: var(--accent-success); }

        .api-info { background: var(--bg-tertiary); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
        .api-info code { background: var(--bg-card); padding: 2px 6px; border-radius: 4px; font-family: 'JetBrains Mono', monospace; font-size: 12px; }

        .nav-buttons { display: flex; justify-content: space-between; margin-top: 40px; padding-top: 24px; border-top: 1px solid var(--border-color); }
        .btn { padding: 12px 24px; border-radius: 10px; font-size: 14px; font-weight: 600; text-decoration: none; display: inline-flex; align-items: center; gap: 8px; cursor: pointer; border: none; transition: all 0.2s; }
        .btn-primary { background: var(--gradient-1); color: white; }
        .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(14, 165, 233, 0.3); }
        .btn-secondary { background: var(--bg-card); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-success { background: var(--accent-success); color: white; }
        .btn-danger { background: var(--accent-danger); color: white; }
        .btn-danger:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(239, 68, 68, 0.3); }

        /* Interactive Controls */
        .control-panel { background: var(--bg-card); border: 1px solid var(--border-color); border-radius: 16px; padding: 28px; margin-bottom: 24px; }
        .control-panel h2 { font-size: 20px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px; }
        .control-panel h2::before { content: "‚ö°"; font-size: 24px; }
        
        .config-form { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; margin-bottom: 24px; }
        .form-group { display: flex; flex-direction: column; gap: 8px; }
        .form-group label { font-size: 12px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; }
        .form-group input, .form-group select { padding: 10px 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 14px; font-family: 'Plus Jakarta Sans', sans-serif; }
        .form-group input:focus, .form-group select:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1); }

        .action-buttons { display: flex; gap: 12px; flex-wrap: wrap; }
        .btn-run-all { background: var(--gradient-execute); color: white; padding: 14px 28px; font-size: 16px; font-weight: 700; }
        .btn-run-all:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(16, 185, 129, 0.3); }

        /* Log Display */
        .log-container { background: #1e293b; border: 1px solid var(--border-color); border-radius: 12px; padding: 20px; margin-top: 24px; max-height: 600px; overflow-y: auto; font-family: 'JetBrains Mono', monospace; font-size: 13px; }
        .log-container::-webkit-scrollbar { width: 8px; }
        .log-container::-webkit-scrollbar-track { background: #0f172a; border-radius: 4px; }
        .log-container::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        .log-container::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        .log-entry { padding: 4px 0; line-height: 1.6; word-wrap: break-word; }
        .log-entry.info { color: #60a5fa; }
        .log-entry.success { color: #34d399; }
        .log-entry.warning { color: #fbbf24; }
        .log-entry.error { color: #f87171; }
        .log-entry.debug { color: #94a3b8; }
        .log-timestamp { color: #64748b; margin-right: 8px; }
        .log-step { color: #a78bfa; font-weight: 600; margin-right: 8px; }

        .status-indicator { display: inline-flex; align-items: center; gap: 8px; padding: 8px 16px; border-radius: 8px; font-size: 14px; font-weight: 600; margin-left: 16px; }
        .status-indicator.idle { background: rgba(148, 163, 184, 0.1); color: var(--text-secondary); }
        .status-indicator.running { background: rgba(14, 165, 233, 0.1); color: var(--accent-primary); }
        .status-indicator.running::before { content: "‚è≥"; animation: spin 1s linear infinite; }
        .status-indicator.success { background: rgba(16, 185, 129, 0.1); color: var(--accent-success); }
        .status-indicator.error { background: rgba(239, 68, 68, 0.1); color: var(--accent-danger); }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .progress-bar { width: 100%; height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden; margin-top: 16px; }
        .progress-fill { height: 100%; background: var(--gradient-execute); transition: width 0.3s ease; width: 0%; }
        
        /* Custom Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 10000; }
        .modal-overlay.show { display: flex; }
        .modal-dialog { background: var(--bg-card); border-radius: 16px; padding: 28px; max-width: 400px; width: 90%; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2); }
        .modal-dialog h3 { margin: 0 0 16px 0; font-size: 20px; color: var(--text-primary); }
        .modal-dialog p { margin: 0 0 24px 0; color: var(--text-secondary); }
        .modal-buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .modal-buttons .btn { min-width: 100px; }
    </style>
</head>
<body>
    <div class="container" style="height: 100vh; overflow-y: scroll;">
        <div class="breadcrumb">
            <a href="index.html">Overview</a><span>‚Ä∫</span><span>Step 6: Execute Pipeline</span>
        </div>
        <div class="page-header">
            <div class="step-badge">6</div>
            <div class="page-title">
                <h1>Execute Pipeline Cycles</h1>
                <p>Run pipeline on entire dataset to stress test nginx gateway</p>
            </div>
        </div>
        <nav class="flow-nav">
            <a href="index.html" class="nav-pill">Overview</a>
            <a href="step1-compute-setup.html" class="nav-pill">Compute Setup</a>
            <a href="step2-project.html" class="nav-pill">Project & Dataset</a>
            <a href="step3-download-images.html" class="nav-pill">Download Images</a>
            <a href="step4-link-items.html" class="nav-pill">Link Items</a>
            <a href="step5-pipeline.html" class="nav-pill">Pipeline</a>
            <a href="step6-execute.html" class="nav-pill active">Execute</a>
        </nav>

        <!-- Interactive Control Panel -->
        <div class="control-panel">
            <h2>Run Full Stress Test Workflow</h2>
            <p style="color: var(--text-secondary); margin-bottom: 20px;">
                Execute all steps sequentially: Download Images ‚Üí Create Link Items ‚Üí Create Pipeline ‚Üí Execute Batch
            </p>
            
            <div class="config-form">
                <div class="form-group">
                    <label>Max Images</label>
                    <input type="number" id="maxImages" value="50000" min="1" max="123287">
                </div>
                <div class="form-group">
                    <label>Dataset ID</label>
                    <input type="text" id="datasetId" value="" placeholder="Dataset ID (empty = auto-create)">
                    <small style="color: var(--text-muted); font-size: 11px; margin-top: 4px; display: block;">Leave empty to automatically create dataset</small>
                </div>
                <div class="form-group">
                    <label>Driver ID <span style="color: var(--accent-warning);">*</span></label>
                    <input type="text" id="driverId" value="" placeholder="Driver ID (mandatory)">
                    <small style="color: var(--text-muted); font-size: 11px; margin-top: 4px; display: block;">Mandatory. Used when creating dataset. Create one in Step 2 if needed.</small>
                </div>
                <div class="form-group">
                    <label>Link Base URL</label>
                    <input type="text" id="linkBaseUrl" value="http://34.140.193.179/s/pd_datfs2/stress-test" placeholder="Link Base URL">
                    <small style="color: var(--text-muted); font-size: 11px; margin-top: 4px; display: block;">Base URL for link items</small>
                </div>
                <div class="form-group">
                    <label>Pipeline Name</label>
                    <input type="text" id="pipelineName" value="stress-test-resnet-v11" placeholder="Pipeline name">
                </div>
                <div class="form-group">
                    <label>Num Workers</label>
                    <input type="number" id="numWorkers" value="50" min="1" max="100">
                </div>
                <div class="form-group">
                    <label>Pipeline Concurrency</label>
                    <input type="number" id="pipelineConcurrency" value="30" min="1" max="50">
                    <small style="color: var(--text-muted); font-size: 11px; margin-top: 4px; display: block;">Concurrent executions per pod</small>
                </div>
                <div class="form-group">
                    <label>Pipeline Max Replicas</label>
                    <input type="number" id="pipelineMaxReplicas" value="12" min="1" max="50">
                    <small style="color: var(--text-muted); font-size: 11px; margin-top: 4px; display: block;">Maximum number of pods</small>
                </div>
            </div>

            <div class="action-buttons">
                <button class="btn btn-run-all" id="runAllBtn" onclick="runFullWorkflow()">
                    üöÄ Run Full Workflow
                </button>
                <button class="btn btn-danger" id="cancelBtn" onclick="cancelWorkflow(); return false;" style="display: none;" title="Cancel workflow and delete pipeline">
                    ‚õî Cancel Workflow
                </button>
                <button class="btn btn-secondary" id="clearLogsBtn" onclick="clearLogs()">
                    üóëÔ∏è Clear Logs
                </button>
                <button class="btn btn-secondary" id="clearCacheBtn" onclick="clearSavedWorkflows(); clearLogs();" title="Clear saved workflow data">
                    üóÑÔ∏è Clear Cache
                </button>
                <span class="status-indicator idle" id="statusIndicator">Idle</span>
            </div>

            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <!-- Log Display -->
        <div class="card">
            <h2>Execution Logs <span style="font-size: 12px; font-weight: normal; color: var(--text-muted);" id="logCount">(0 entries)</span></h2>
            <div class="log-container" id="logContainer">
                <div class="log-entry info">Ready to run workflow. Click "Run Full Workflow" to start.</div>
            </div>
        </div>

        <div class="card">
            <h2>Execution Flow</h2>
            <div class="exec-flow">
                <div class="flow-box" id="step1"><div class="icon">üì•</div><div class="label">Download Images</div></div>
                <span class="flow-arrow">‚Üí</span>
                <div class="flow-box" id="step2"><div class="icon">üîó</div><div class="label">Link Items</div></div>
                <span class="flow-arrow">‚Üí</span>
                <div class="flow-box" id="step3"><div class="icon">‚öôÔ∏è</div><div class="label">Create Pipeline</div></div>
                <span class="flow-arrow">‚Üí</span>
                <div class="flow-box" id="step4"><div class="icon">‚ñ∂Ô∏è</div><div class="label">Execute Batch</div></div>
            </div>
        </div>

        <div class="card">
            <h2><span class="method-badge method-recommended">RECOMMENDED</span>Execute Batch on Entire Dataset</h2>
            <p style="margin-bottom: 16px; color: var(--text-secondary);">Uses Piper's batch execution command to efficiently run the pipeline on all dataset items.</p>
            
            <div class="api-info">
                <strong>API Endpoint:</strong> <code>POST /pipelines/{pipelineId}/execute</code><br>
                <strong>How it works:</strong> Piper creates a GenerateExecutionsCmd that fetches items in batches and triggers pipeline cycles for each item.
            </div>

        </div>

        <div class="card">
            <h2>Pre-Execution Checklist</h2>
            <ul class="checklist">
                <li><span class="check-icon">‚úì</span>Compute setup completed (dev-env 2)</li>
                <li><span class="check-icon">‚úì</span>Rubiks v1.41.1-rc.18 deployed</li>
                <li><span class="check-icon">‚úì</span>Project and faasProxy dataset created</li>
                <li><span class="check-icon">‚úì</span>Images downloaded to Storage</li>
                <li><span class="check-icon">‚úì</span>Link items created in dataset</li>
                <li><span class="check-icon">‚úì</span>Pipeline created with ResNet function</li>
                <li><span class="check-icon">‚úì</span>Monitoring dashboards ready</li>
            </ul>
        </div>

        <div class="nav-buttons">
            <a href="step5-pipeline.html" class="btn btn-secondary">‚Üê Back to Pipeline</a>
            <a href="index.html" class="btn btn-primary">Back to Overview ‚Üí</a>
        </div>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="confirmModal" class="modal-overlay">
        <div class="modal-dialog">
            <h3 id="confirmModalTitle">Confirm Action</h3>
            <p id="confirmModalMessage">Are you sure?</p>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="confirmModalCancel">Cancel</button>
                <button class="btn btn-danger" id="confirmModalConfirm">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // Use relative API paths - will be served by DPK custom server
        const API_BASE_URL = window.location.origin;
        let isRunning = false;
        let currentExecutions = [];
        let currentWorkflowId = null; // Track current workflow ID

        // Track the progress line element for batch execution
        let batchProgressLine = null;
        
        // Custom confirmation function (replaces blocked confirm())
        function showConfirm(title, message) {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirmModal');
                const titleEl = document.getElementById('confirmModalTitle');
                const messageEl = document.getElementById('confirmModalMessage');
                const confirmBtn = document.getElementById('confirmModalConfirm');
                const cancelBtn = document.getElementById('confirmModalCancel');
                
                titleEl.textContent = title;
                messageEl.textContent = message;
                
                const cleanup = () => {
                    modal.classList.remove('show');
                    confirmBtn.onclick = null;
                    cancelBtn.onclick = null;
                };
                
                confirmBtn.onclick = () => {
                    cleanup();
                    resolve(true);
                };
                
                cancelBtn.onclick = () => {
                    cleanup();
                    resolve(false);
                };
                
                modal.classList.add('show');
            });
        }
        
        // localStorage keys
        const STORAGE_KEY_WORKFLOWS = 'stress_test_workflows';
        const STORAGE_KEY_CURRENT_WORKFLOW = 'stress_test_current_workflow';
        const STORAGE_KEY_MAX_IMAGES = 'stress_test_max_images';
        
        // Save workflow progress to localStorage
        function saveWorkflowProgress(workflowId, progress) {
            try {
                // Save current workflow
                if (workflowId) {
                    localStorage.setItem(STORAGE_KEY_CURRENT_WORKFLOW, workflowId);
                }
                
                // Get all saved workflows
                const savedWorkflows = JSON.parse(localStorage.getItem(STORAGE_KEY_WORKFLOWS) || '{}');
                
                // Update with current progress
                savedWorkflows[workflowId] = {
                    ...progress,
                    lastUpdated: Date.now(),
                    workflowId: workflowId
                };
                
                // Save back to localStorage
                localStorage.setItem(STORAGE_KEY_WORKFLOWS, JSON.stringify(savedWorkflows));
            } catch (e) {
                console.error('Failed to save workflow progress:', e);
            }
        }
        
        // Load workflow progress from localStorage
        function loadWorkflowProgress(workflowId) {
            try {
                const savedWorkflows = JSON.parse(localStorage.getItem(STORAGE_KEY_WORKFLOWS) || '{}');
                return savedWorkflows[workflowId] || null;
            } catch (e) {
                console.error('Failed to load workflow progress:', e);
                return null;
            }
        }
        
        // Get all saved workflows
        function getAllSavedWorkflows() {
            try {
                return JSON.parse(localStorage.getItem(STORAGE_KEY_WORKFLOWS) || '{}');
            } catch (e) {
                console.error('Failed to load saved workflows:', e);
                return {};
            }
        }
        
        // Restore workflow from localStorage
        function restoreWorkflow(workflowId) {
            const saved = loadWorkflowProgress(workflowId);
            if (!saved) return false;

            // Restore UI state
            updateProgress(saved.progress_pct || 0);
            updateStatus(saved.status || 'unknown', saved.current_step || '');

            // Restore logs
            clearLogs();
            if (saved.logs && saved.logs.length > 0) {
                saved.logs.forEach(log => {
                    const level = log.level?.toLowerCase() || 'info';
                    const step = log.step || null;
                    addLog(`${step ? `[${step}] ` : ''}${log.message}`, level, step);
                });
            }

            // If workflow is still running, resume polling
            if (saved.status === 'running' || saved.status === 'unknown') {
                addLog(`üîÑ Resuming workflow monitoring...`, 'info');
                currentWorkflowId = workflowId;
                pollWorkflowProgress(workflowId);
            } else {
                addLog(`üìã Loaded saved workflow result (${saved.status})`, 'info');
            }

            return true;
        }

        // Attach to an active workflow from the server (for users who didn't start the test - no localStorage).
        // Fetches current progress, displays all logs, and starts polling so they see the same as the initiator.
        async function attachToActiveWorkflow(workflowId) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/workflow-progress/${workflowId}`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (!response.ok) return false;
                const progress = await response.json();
                const status = progress.status || 'unknown';
                const progressPct = progress.progress_pct || 0;
                const currentStep = progress.current_step || '';

                updateProgress(progressPct);
                updateStatus(status, currentStep);
                clearLogs();
                if (progress.logs && progress.logs.length > 0) {
                    replaceLogsWith(progress.logs);
                }
                addLog(`üìã Attached to running test (workflow ${workflowId.slice(0, 8)}‚Ä¶). Showing all logs and polling.`, 'info');
                saveWorkflowProgress(workflowId, progress);
                currentWorkflowId = workflowId;

                const stillRunning = ['running', 'starting', 'cancelling', 'unknown'].includes(status);
                if (stillRunning) {
                    isRunning = true;
                    const runBtn = document.getElementById('runAllBtn');
                    if (runBtn) {
                        runBtn.disabled = true;
                        runBtn.textContent = '‚è≥ Running...';
                    }
                    const cancelBtn = document.getElementById('cancelBtn');
                    if (cancelBtn) {
                        cancelBtn.style.display = 'inline-flex';
                        cancelBtn.disabled = false;
                    }
                    window._pollingWorkflowId = workflowId;
                    pollWorkflowProgress(workflowId);
                } else {
                    addLog(`üìã Workflow already finished (${status})`, 'info');
                }
                return true;
            } catch (e) {
                console.error('attachToActiveWorkflow error:', e);
                return false;
            }
        }
        
        // Clear saved workflows
        function clearSavedWorkflows() {
            try {
                localStorage.removeItem(STORAGE_KEY_WORKFLOWS);
                localStorage.removeItem(STORAGE_KEY_CURRENT_WORKFLOW);
                addLog('üóëÔ∏è Cleared saved workflow data', 'info');
            } catch (e) {
                console.error('Failed to clear saved workflows:', e);
            }
        }
        
        function addLog(message, level = 'info', step = null) {
            const container = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            
            const timestamp = new Date().toLocaleTimeString();
            let html = `<span class="log-timestamp">[${timestamp}]</span>`;
            if (step) {
                html += `<span class="log-step">[${step}]</span>`;
            }
            html += message;
            
            entry.innerHTML = html;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
            
            // Update log count
            const count = container.children.length;
            document.getElementById('logCount').textContent = `(${count} entries)`;
        }
        
        // Replace log container with server logs (used when backend trims and we need to resync)
        function replaceLogsWith(logs) {
            const container = document.getElementById('logContainer');
            if (!container) return;
            container.innerHTML = '';
            batchProgressLine = null;
            (logs || []).forEach(log => {
                const level = log.level?.toLowerCase() || 'info';
                const step = log.step || null;
                const message = log.message || '';
                const entry = document.createElement('div');
                entry.className = `log-entry ${level}`;
                const timestamp = new Date().toLocaleTimeString();
                let html = `<span class="log-timestamp">[${timestamp}]</span>`;
                if (step) html += `<span class="log-step">[${step}]</span>`;
                entry.innerHTML = html + message;
                container.appendChild(entry);
            });
            container.scrollTop = container.scrollHeight;
            const countEl = document.getElementById('logCount');
            if (countEl) countEl.textContent = `(${logs.length} entries)`;
        }
        
        function updateBatchProgressLog(message, level = 'info', step = null) {
            const container = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            let html = `<span class="log-timestamp">[${timestamp}]</span>`;
            if (step) {
                html += `<span class="log-step">[${step}]</span> `;
            }
            html += message;
            
            if (batchProgressLine && batchProgressLine.parentNode) {
                // Update existing progress line in place
                batchProgressLine.innerHTML = html;
                batchProgressLine.className = `log-entry ${level}`;
            } else {
                // Create new progress line if it doesn't exist or was removed
                const entry = document.createElement('div');
                entry.className = `log-entry ${level}`;
                entry.innerHTML = html;
                container.appendChild(entry);
                batchProgressLine = entry;
                
                // Update log count (don't count this as a new entry since it's updating)
                // Actually, we should count it once when created
                const count = container.children.length;
                document.getElementById('logCount').textContent = `(${count} entries)`;
            }
            // Always scroll to bottom to see the latest progress
            container.scrollTop = container.scrollHeight;
        }
        
        function clearBatchProgressLine() {
            batchProgressLine = null;
        }

        function clearLogs() {
            const container = document.getElementById('logContainer');
            container.innerHTML = '';
            document.getElementById('logCount').textContent = '(0 entries)';
            clearBatchProgressLine();
        }

        function updateStatus(status, message = '') {
            const indicator = document.getElementById('statusIndicator');
            indicator.className = `status-indicator ${status}`;
            indicator.textContent = message || status.charAt(0).toUpperCase() + status.slice(1);
            
            // Show/hide cancel button based on status
            const cancelBtn = document.getElementById('cancelBtn');
            if (cancelBtn) {
                if (status === 'running' || status === 'unknown') {
                    cancelBtn.style.display = 'inline-flex';
                    cancelBtn.disabled = false; // Ensure button is enabled when shown
                } else {
                    cancelBtn.style.display = 'none';
                }
            }
        }
        
        async function cancelWorkflow() {
            console.log('=== cancelWorkflow called ===');
            console.log('currentWorkflowId:', currentWorkflowId);
            console.log('window._pollingWorkflowId:', window._pollingWorkflowId);
            
            const cancelBtn = document.getElementById('cancelBtn');
            console.log('Cancel button found:', !!cancelBtn);
            if (cancelBtn) {
                console.log('Cancel button disabled:', cancelBtn.disabled);
                console.log('Cancel button display:', cancelBtn.style.display);
            }
            
            if (cancelBtn && cancelBtn.disabled) {
                console.log('Cancel button is disabled, ignoring click');
                addLog('‚ö†Ô∏è Cancel button is disabled', 'warning');
                return;
            }
            
            // Try to get workflow ID from polling flag if currentWorkflowId is not set
            if (!currentWorkflowId && window._pollingWorkflowId) {
                console.log('Using polling workflow ID:', window._pollingWorkflowId);
                currentWorkflowId = window._pollingWorkflowId;
            }
            
            if (!currentWorkflowId) {
                addLog('‚ö†Ô∏è No active workflow to cancel', 'warning');
                console.warn('No currentWorkflowId set - cannot cancel');
                return;
            }
            
            // Use custom confirmation modal (since confirm() is blocked in sandboxed iframes)
            const confirmed = await showConfirm(
                'Cancel Workflow',
                'Are you sure you want to cancel this workflow? This will uninstall and delete the pipeline.'
            );
            
            if (!confirmed) {
                console.log('User cancelled the confirmation dialog');
                return;
            }
            
            if (cancelBtn) {
                cancelBtn.disabled = true;
                cancelBtn.textContent = '‚è≥ Cancelling...';
            }
            
            // Immediately show cancellation message
            addLog('‚õî Cancellation requested - stopping workflow and cleaning up pipeline...', 'warning');
            updateStatus('cancelling', 'Cancelling...');
            
            try {
                console.log(`Calling cancel API: ${API_BASE_URL}/api/cancel-workflow/${currentWorkflowId}`);
                const response = await fetch(`${API_BASE_URL}/api/cancel-workflow/${currentWorkflowId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                console.log('Cancel API response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Cancel API error:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                console.log('Cancel API result:', result);
                
                if (result.error) {
                    throw new Error(result.error);
                }
                
                // Show success message immediately
                addLog(`‚úì ${result.message || 'Workflow cancellation initiated'}`, 'success');
                updateStatus('cancelling', 'Cancelling...');
                
                // Immediately fetch and display cancellation logs
                try {
                    const logResponse = await fetch(`${API_BASE_URL}/api/workflow-progress/${currentWorkflowId}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    if (logResponse.ok) {
                        const logProgress = await logResponse.json();
                        const status = logProgress.status || 'unknown';
                        console.log('Workflow status after cancel:', status);
                        
                        // Add all cancellation-related logs immediately
                        if (logProgress.logs && logProgress.logs.length > 0) {
                            const cancelLogs = logProgress.logs.filter(log => 
                                log.step === 'cancel' || 
                                log.message.toLowerCase().includes('cancel') || 
                                log.message.toLowerCase().includes('uninstall') || 
                                log.message.toLowerCase().includes('delete') ||
                                log.message.toLowerCase().includes('pipeline')
                            );
                            cancelLogs.forEach(log => {
                                const level = log.level?.toLowerCase() || 'info';
                                addLog(`[${log.step || 'cancel'}] ${log.message}`, level);
                            });
                        }
                        
                        if (status === 'cancelled') {
                            updateStatus('cancelled', 'Cancelled');
                            addLog('‚õî Workflow cancelled - pipeline uninstalled and deleted', 'warning');
                        } else if (status === 'cancelling') {
                            updateStatus('cancelling', 'Cancelling...');
                            addLog('‚è≥ Cancellation in progress...', 'info');
                        }
                    }
                } catch (logError) {
                    console.error('Error fetching cancellation logs:', logError);
                }
                
            } catch (error) {
                console.error('Cancel workflow error:', error);
                addLog(`‚ùå Error cancelling workflow: ${error.message}`, 'error');
                updateStatus('error', 'Cancel Failed');
            } finally {
                if (cancelBtn) {
                    cancelBtn.disabled = false;
                    cancelBtn.textContent = '‚õî Cancel Workflow';
                }
            }
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            progressBar.style.display = 'block';
            progressFill.style.width = `${percent}%`;
        }

        function highlightStep(stepNum, active = false) {
            const step = document.getElementById(`step${stepNum}`);
            if (active) {
                step.classList.add('highlight');
            } else {
                step.classList.remove('highlight');
            }
        }

        async function runFullWorkflow() {
            if (isRunning) {
                addLog('Workflow is already running!', 'warning');
                return;
            }

            isRunning = true;
            const runBtn = document.getElementById('runAllBtn');
            runBtn.disabled = true;
            runBtn.textContent = '‚è≥ Running...';
            
            updateStatus('running', 'Running Workflow');
            clearLogs();
            clearBatchProgressLine();
            addLog('Starting full stress test workflow...', 'info');
            updateProgress(0);
            currentWorkflowId = null; // Reset current workflow
            
            // Show cancel button
            const cancelBtn = document.getElementById('cancelBtn');
            if (cancelBtn) {
                cancelBtn.style.display = 'none'; // Will be shown when workflow starts
            }

            const config = {
                maxImages: parseInt(document.getElementById('maxImages').value),
                datasetId: document.getElementById('datasetId').value,
                driverId: (document.getElementById('driverId').value || '').trim(),
                linkBaseUrl: document.getElementById('linkBaseUrl').value,
                pipelineName: document.getElementById('pipelineName').value,
                // Project ID is optional - will be auto-detected from service
                numWorkers: parseInt(document.getElementById('numWorkers').value),
                pipelineConcurrency: parseInt(document.getElementById('pipelineConcurrency').value),
                pipelineMaxReplicas: parseInt(document.getElementById('pipelineMaxReplicas').value)
            };

            if (!config.driverId) {
                addLog('Driver ID is mandatory.', 'error');
                updateStatus('error', 'Failed');
                isRunning = false;
                runBtn.disabled = false;
                runBtn.textContent = 'üöÄ Run Full Workflow';
                return;
            }

            try {
                // Use the /api/run-full endpoint which handles all steps including dataset creation
                addLog('Starting full workflow via /api/run-full endpoint...', 'info');
                updateProgress(5);
                
                const response = await fetch(`${API_BASE_URL}/api/run-full`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                const resultText = await response.text();
                let result = {};
                try {
                    result = JSON.parse(resultText);
                } catch (_) {
                    result = { error: resultText || `HTTP ${response.status}` };
                }
                if (!response.ok) {
                    const errMsg = result.error || result.message || resultText || `HTTP ${response.status}`;
                    throw new Error(errMsg);
                }
                if (result.error) {
                    throw new Error(result.error);
                }

                if (!result.workflow_id) {
                    throw new Error('No workflow_id returned from server');
                }

                currentWorkflowId = result.workflow_id;
                addLog(`‚úì Workflow started: ${result.workflow_id}`, 'success');
                updateStatus('running', 'Workflow Running');
                updateProgress(5);
                
                // Show cancel button now that workflow is running
                const cancelBtn = document.getElementById('cancelBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = 'inline-flex';
                    cancelBtn.disabled = false; // Ensure button is enabled
                }
                
                // Initialize polling flag
                window._pollingWorkflowId = result.workflow_id;
                
                // Poll for workflow progress
                await pollWorkflowProgress(result.workflow_id);
                
            } catch (error) {
                addLog(`‚ùå Error: ${error.message}`, 'error');
                updateStatus('error', 'Failed');
                console.error('Workflow error:', error);
            } finally {
                isRunning = false;
                runBtn.disabled = false;
                runBtn.textContent = 'üöÄ Run Full Workflow';
                
                // Hide cancel button if workflow is not running
                const cancelBtn = document.getElementById('cancelBtn');
                if (cancelBtn && !currentWorkflowId) {
                    cancelBtn.style.display = 'none';
                }
            }
        }

        async function executeStep(functionName, executionInput, config) {
            try {
                // Call DPK API endpoint
                const response = await fetch(`${API_BASE_URL}/api/execute`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        service_id: config.service_id,
                        project_id: config.project_id,
                        function_name: functionName,
                        execution_input: executionInput
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                }

                const result = await response.json();
                
                // Poll for execution status and logs
                if (result.execution_id) {
                    await pollExecutionLogs(result.execution_id, config);
                }
                
                return result;
            } catch (error) {
                addLog(`‚ùå Error executing ${functionName}: ${error.message}`, 'error');
                throw error;
            }
        }

        async function pollWorkflowProgress(workflowId) {
            let pollCount = 0;
            const maxPolls = 3600; // Poll for up to 1 hour (3600 * 1 second)
            let lastLogCount = 0;
            let shouldStopPolling = false; // Flag to stop polling when cancelled
            
            // Store polling flag in global scope so cancel can stop it
            window._pollingWorkflowId = workflowId;
            
            while (pollCount < maxPolls && !shouldStopPolling) {
                // Check if workflow was cancelled externally (but still poll once more to get logs)
                if (window._pollingWorkflowId !== workflowId && pollCount > 0) {
                    shouldStopPolling = true;
                    break;
                }
                try {
                    const response = await fetch(`${API_BASE_URL}/api/workflow-progress/${workflowId}`, {
                        method: 'GET',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) {
                        if (response.status === 404) {
                            addLog('‚ö† Workflow not found - may have been cleared', 'warning');
                            break;
                        }
                        throw new Error(`HTTP ${response.status}: ${await response.text()}`);
                    }

                    const progress = await response.json();
                    
                    // Save progress to localStorage
                    saveWorkflowProgress(workflowId, progress);
                    
                    // Update status
                    const status = progress.status || 'unknown';
                    const currentStep = progress.current_step || 'unknown';
                    const progressPct = progress.progress_pct || 0;
                    
                    // Update progress bar
                    updateProgress(progressPct);
                    
                    // Update status indicator
                    if (status === 'completed') {
                        updateStatus('success', 'Completed');
                    } else if (status === 'failed') {
                        updateStatus('error', 'Failed');
                    } else if (status === 'cancelled' || status === 'cancelling') {
                        updateStatus('error', status === 'cancelling' ? 'Cancelling...' : 'Cancelled');
                    } else {
                        updateStatus('running', `${currentStep} (${progressPct}%)`);
                    }
                    
                    // Add new logs (only new ones since last poll)
                    // When backend trims to 1800, length stays same so we resync to get latest logs
                    const logs = progress.logs || [];
                    const LOG_TRIM_SIZE = 1800; // Must match backend limit (~1‚Äì1.5 MB)
                    if (logs.length === lastLogCount && lastLogCount >= LOG_TRIM_SIZE) {
                        // At trim size and count unchanged - backend likely trimmed; replace with server's latest
                        replaceLogsWith(logs);
                        lastLogCount = logs.length;
                    } else if (logs.length > lastLogCount) {
                        const newLogs = logs.slice(lastLogCount);
                        newLogs.forEach(log => {
                            const level = log.level?.toLowerCase() || 'info';
                            const step = log.step || null;
                            const message = log.message || '';
                            
                            // Always show cancellation-related logs immediately
                            if (step === 'cancel' || message.toLowerCase().includes('cancel') || 
                                message.toLowerCase().includes('uninstall') || 
                                message.toLowerCase().includes('delete') ||
                                message.toLowerCase().includes('pipeline')) {
                                addLog(`${step ? `[${step}] ` : ''}${message}`, level);
                                clearBatchProgressLine(); // Clear any batch progress when cancellation logs appear
                            }
                            // Check if this is a batch execution progress update
                            else if (step === 'execute_pipeline_batch' && 
                                (message.includes('Progress:') || 
                                 message.includes('items completed') || 
                                 message.includes('Success:') || 
                                 message.includes('Failed:') ||
                                 message.includes('In Progress:') ||
                                 message.includes('Waiting for statistics') ||
                                 message.includes('Polling') ||
                                 message.includes('Elapsed:'))) {
                                // Update the progress line in place
                                updateBatchProgressLog(message, level, step);
                            } else {
                                // Regular log entry - append new line
                                addLog(`${step ? `[${step}] ` : ''}${message}`, level);
                                // Clear batch progress line if we're moving to a different step
                                if (step && step !== 'execute_pipeline_batch') {
                                    clearBatchProgressLine();
                                }
                            }
                        });
                        lastLogCount = logs.length;
                    }
                    
                    // Check if workflow is complete, cancelled, or cancelling
                    if (status === 'completed' || status === 'cancelled' || status === 'cancelling') {
                        // Clear batch progress line when workflow completes
                        clearBatchProgressLine();
                        // Save final state
                        saveWorkflowProgress(workflowId, progress);
                        if (status === 'cancelled') {
                            addLog('‚õî Workflow cancelled - pipeline uninstalled and deleted', 'warning');
                            shouldStopPolling = true;
                        } else if (status === 'cancelling') {
                            addLog('‚è≥ Workflow cancellation in progress...', 'warning');
                            // Continue polling to see cancellation logs
                        } else if (progress.result) {
                            addLog('üéâ Full workflow completed successfully!', 'success');
                            // Show summary
                            if (progress.result.steps) {
                                progress.result.steps.forEach(step => {
                                    if (step.step && step.result) {
                                        const stepResult = step.result;
                                        if (stepResult.error) {
                                            addLog(`  ${step.step}: ‚ùå ${stepResult.error}`, 'error');
                                        } else if (step.step === 'download_images') {
                                            addLog(`  ${step.step}: ‚úì ${stepResult.downloaded || 0} downloaded, ${stepResult.actual_files_on_disk || 0} files on disk`, 'success');
                                        } else if (step.step === 'create_link_items') {
                                            addLog(`  ${step.step}: ‚úì ${stepResult.created || 0} items created`, 'success');
                                        } else if (step.step === 'create_pipeline') {
                                            addLog(`  ${step.step}: ‚úì Pipeline ${stepResult.pipeline_id} created`, 'success');
                                        } else if (step.step === 'execute_pipeline_batch') {
                                            addLog(`  ${step.step}: ‚úì Batch started on ${stepResult.items_count || 0} items`, 'success');
                                        }
                                    }
                                });
                            }
                        } else {
                            addLog('‚úì Workflow completed', 'success');
                        }
                        break;
                    } else if (status === 'failed') {
                        // Clear batch progress line when workflow fails
                        clearBatchProgressLine();
                        // Save final state
                        saveWorkflowProgress(workflowId, progress);
                        const errorMsg = progress.error || 'Unknown error';
                        addLog(`‚úó Workflow failed: ${errorMsg}`, 'error');
                        shouldStopPolling = true;
                        break;
                    }
                    
                    // Check if we should stop polling (cancelled externally)
                    if (shouldStopPolling || window._pollingWorkflowId !== workflowId) {
                        addLog('‚èπÔ∏è Polling stopped', 'info');
                        break;
                    }
                } catch (error) {
                    addLog(`Polling error: ${error.message}`, 'warning');
                }
                
                // Check if we should stop before next poll
                if (shouldStopPolling || window._pollingWorkflowId !== workflowId) {
                    break;
                }
                
                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second
                pollCount++;
            }
            
            // Clear polling flag
            if (window._pollingWorkflowId === workflowId) {
                window._pollingWorkflowId = null;
            }
            
            if (pollCount >= maxPolls && !shouldStopPolling) {
                addLog('‚ö† Polling timeout - workflow may still be running', 'warning');
            }
        }

        // Save max images to localStorage
        function saveMaxImages(value) {
            try {
                localStorage.setItem(STORAGE_KEY_MAX_IMAGES, value.toString());
            } catch (e) {
                console.error('Failed to save max images:', e);
            }
        }
        
        // Load max images from localStorage
        function loadMaxImages() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY_MAX_IMAGES);
                if (saved) {
                    const value = parseInt(saved, 10);
                    if (!isNaN(value) && value >= 1 && value <= 123287) {
                        return value;
                    }
                }
            } catch (e) {
                console.error('Failed to load max images:', e);
            }
            return 50000; // Default value
        }
        
        // Check backend server status on load
        window.addEventListener('load', async () => {
            // Restore max images from localStorage
            try {
                const savedMaxImages = loadMaxImages();
                const maxImagesInput = document.getElementById('maxImages');
                if (maxImagesInput && savedMaxImages !== 50000) {
                    maxImagesInput.value = savedMaxImages;
                }
            } catch (e) {
                console.error('Failed to restore max images:', e);
            }
            
            // Add event listener to save max images when changed
            const maxImagesInput = document.getElementById('maxImages');
            if (maxImagesInput) {
                maxImagesInput.addEventListener('change', function() {
                    const value = parseInt(this.value, 10);
                    if (!isNaN(value) && value >= 1 && value <= 123287) {
                        saveMaxImages(value);
                    }
                });
                maxImagesInput.addEventListener('blur', function() {
                    const value = parseInt(this.value, 10);
                    if (!isNaN(value) && value >= 1 && value <= 123287) {
                        saveMaxImages(value);
                    }
                });
            }
            
            // Setup cancel button event listener (backup to onclick)
            const cancelBtn = document.getElementById('cancelBtn');
            if (cancelBtn) {
                // Add event listener (onclick is already set as backup)
                cancelBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Cancel button clicked via event listener');
                    cancelWorkflow();
                    return false;
                }, true); // Use capture phase to ensure it fires
                console.log('Cancel button event listener attached');
            } else {
                console.error('Cancel button not found!');
            }
            
            // Check server connection
            try {
                const response = await fetch(`${API_BASE_URL}/api/health`);
                if (response.ok) {
                    addLog('‚úì DPK server connected', 'success');
                }
            } catch (error) {
                addLog('‚ö†Ô∏è Could not connect to DPK server', 'warning');
            }

            // On load: verify if a test is already running on the server (e.g. another user started it).
            // If yes, attach to it and poll so this user sees the same logs as everyone else.
            try {
                const activeRes = await fetch(`${API_BASE_URL}/api/active-workflow`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (activeRes.ok) {
                    const active = await activeRes.json();
                    if (active.running && active.workflow_id) {
                        addLog('üîó A test is already running on the server. Attaching to view logs...', 'info');
                        const attached = await attachToActiveWorkflow(active.workflow_id);
                        if (attached) {
                            // Done: we are now polling and showing logs; skip localStorage restore
                            return;
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to check active workflow:', e);
            }
            
            // Restore workflow from localStorage (same browser had started or viewed a workflow before)
            try {
                const savedWorkflowId = localStorage.getItem('stress_test_current_workflow');
                if (savedWorkflowId) {
                    const saved = loadWorkflowProgress(savedWorkflowId);
                    if (saved) {
                        if (saved.status === 'running' || saved.status === 'unknown') {
                            // Workflow might still be running, restore and resume polling
                            setTimeout(() => {
                                addLog('üìã Found saved workflow, restoring and resuming monitoring...', 'info');
                                restoreWorkflow(savedWorkflowId);
                            }, 1000);
                        } else {
                            // Workflow is completed, just show the result
                            setTimeout(() => {
                                addLog('üìã Found saved workflow result', 'info');
                                restoreWorkflow(savedWorkflowId);
                            }, 1000);
                        }
                    }
                }
            } catch (e) {
                console.error('Failed to restore workflow:', e);
            }
        });
    </script>
</body>
</html>
